import { makePointBoard } from "./board.js";
import { makePointSolver } from "./solver.js";
function split(r) {
    const r1 = {};
    const r2 = {};
    let once = undefined;
    for (const k in r) {
        if (!once) {
            r1[k] = r[k];
            once = k;
        }
        else {
            r2[k] = r[k];
        }
    }
    return [once, r1, r2];
}
// given the usual inputs for a Solver, instead pick one shape to place to generate a set of partially solved boards
// and generate a series of data required to continue the computation separately
export function partialSolve(board, shapes, blocked, inspect) {
    const [k, first, rest] = split(shapes);
    const solver = makePointSolver(makePointBoard(board), first, (set, pi) => {
        blocked.forEach((p) => set(p, "-"));
        inspect(pi);
    });
    return (partialCallback) => {
        const remainingShapes = rest;
        const callback = (pi, e) => {
            if (e.kind === "solved") {
                const piece = board.filter(p => pi(p) === k);
                const task = {
                    placed: piece,
                    picked: blocked,
                    shapes: remainingShapes,
                    board_points: board
                };
                partialCallback(task);
            }
        };
        return solver(callback);
    };
}
// generate a solver to continue the partial solution generated by partialSolve 
export function continueSolve(data, inspect) {
    return makePointSolver(makePointBoard(data.board_points), data.shapes, (set, pi) => {
        data.picked.forEach((p) => set(p, "-"));
        data.placed.forEach((p) => set(p, "!"));
        inspect(pi);
    });
}
//# sourceMappingURL=parallelizer.js.map